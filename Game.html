<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Kingdom | Quiz Studio</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;600;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

    <style>
        :root {
            --hex-width: 90px; 
            --hex-height: 100px;
            --hex-margin-top: -35px; 
            --hex-indent: 45px; 
            --grass: #8bc34a; --water: #29b6f6; --forest: #388e3c; --mountain: #546e7a;
            --red: #e53935; --blue: #1e88e5; --gold: #ffca28; --bg: #102027;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Be Vietnam Pro', sans-serif; }

        body {
            background-color: var(--bg);
            background-image: radial-gradient(circle at 10% 20%, rgba(229, 57, 53, 0.1) 0%, transparent 40%),
                              radial-gradient(circle at 90% 80%, rgba(30, 136, 229, 0.1) 0%, transparent 40%);
            color: white; height: 100vh; display: flex; flex-direction: column; overflow: hidden; user-select: none;
        }

        #toastArea { position: fixed; top: 100px; left: 50%; transform: translateX(-50%); z-index: 9999; pointer-events: none; width: 80%; max-width: 400px; }
        .toast { background: rgba(255,255,255,0.95); color: #333; padding: 12px 20px; margin-bottom: 10px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); font-weight: 700; display: flex; align-items: center; gap: 10px; animation: slideIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); border-left: 6px solid var(--gold); backdrop-filter: blur(4px); }
        .toast.success { border-left-color: #2ecc71; }
        .toast.error { border-left-color: var(--red); }
        @keyframes slideIn { from { transform: translateY(-30px); opacity: 0; } }

        .turn-banner { background: rgba(0,0,0,0.6); color: white; text-align: center; padding: 8px 0; font-weight: 800; font-size: 1rem; text-transform: uppercase; letter-spacing: 3px; transition: 0.3s; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .turn-banner.red { background: linear-gradient(90deg, transparent, rgba(229, 57, 53, 0.8), transparent); text-shadow: 0 0 10px var(--red); }
        .turn-banner.blue { background: linear-gradient(90deg, transparent, rgba(30, 136, 229, 0.8), transparent); text-shadow: 0 0 10px var(--blue); }

        header { height: 70px; padding: 0 20px; display: flex; justify-content: space-between; align-items: center; background: rgba(38, 50, 56, 0.8); backdrop-filter: blur(10px); z-index: 50; }
        .hud { display: flex; align-items: center; gap: 10px; padding: 5px 20px; border-radius: 50px; background: rgba(255,255,255,0.05); border: 2px solid transparent; transition: 0.3s; min-width: 120px; }
        .hud.red.active { border-color: var(--red); background: rgba(229, 57, 53, 0.2); transform: scale(1.05); }
        .hud.blue.active { border-color: var(--blue); background: rgba(30, 136, 229, 0.2); transform: scale(1.05); }
        .score { font-size: 1.8rem; font-weight: 900; line-height: 1; }
        .timer { font-size: 1.5rem; font-weight: 800; font-variant-numeric: tabular-nums; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 8px; color: var(--gold); border: 1px solid rgba(255,255,255,0.1); }

        main { flex: 1; display: flex; justify-content: center; align-items: center; overflow: hidden; cursor: grab; position: relative; }
        main:active { cursor: grabbing; }
        .map-scaler { transform-origin: center; transition: transform 0.4s ease-out; padding: 50px; }

        .hex-grid { display: flex; flex-direction: column; align-items: center; padding-top: 40px; }
        .hex-row { display: flex; justify-content: center; margin-top: var(--hex-margin-top); }
        .hex-row:nth-child(even) { margin-left: var(--hex-indent); }
        .hex { width: var(--hex-width); height: var(--hex-height); clip-path: polygon(50% 0%, 100% 25%, 100% 85%, 50% 100%, 0% 85%, 0% 25%); background: var(--grass); margin: 0 1px; display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3); }
        .hex::after { content: ''; position: absolute; inset: 0; background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0.2) 100%); pointer-events: none; }
        .hex:hover { transform: translateY(-5px) scale(1.1); z-index: 100; filter: brightness(1.3); }

        .hex.grass { background: var(--grass); color: rgba(255,255,255,0.8); }
        .hex.water { background: var(--water); cursor: not-allowed; opacity: 0.9; }
        .hex.forest { background: var(--forest); cursor: not-allowed; }
        .hex.mountain { background: var(--mountain); cursor: not-allowed; }
        
        .hex.red { background: var(--red); animation: popIn 0.4s; z-index: 5; }
        .hex.blue { background: var(--blue); animation: popIn 0.4s; z-index: 5; }

        .hex.base { z-index: 20; }
        .hex.base-red { background: #b71c1c; border-bottom: 4px solid rgba(0,0,0,0.5); }
        .hex.base-blue { background: #0d47a1; border-bottom: 4px solid rgba(0,0,0,0.5); }

        @keyframes popIn { 0% { transform: scale(0.5); } 80% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes siege { 0% { transform: scale(1); } 50% { transform: scale(0.9) rotate(5deg); box-shadow: 0 0 20px red; } 100% { transform: scale(1); } }
        .hex.die { animation: siege 0.5s infinite; filter: grayscale(0.8) brightness(0.5); }

        .hex-content { font-size: 1.4rem; font-weight: 900; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.4); }
        .icon-lg { font-size: 2rem; color: white; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.6)); }

        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 2000; backdrop-filter: blur(8px); padding: 20px; }
        .modal-overlay.open { display: flex; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .card { background: #eceff1; color: #333; padding: 25px; border-radius: 24px; width: 100%; max-width: 600px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.8); max-height: 90vh; overflow-y: auto; position: relative; }
        .q-img { max-height: 250px; max-width: 100%; object-fit: contain; border-radius: 12px; margin-bottom: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .q-text { font-size: 1.3rem; font-weight: 700; margin-bottom: 20px; color: #263238; line-height: 1.4; }
        .opts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        
        .btn-opt { padding: 15px; border: none; border-radius: 16px; background: white; font-weight: 700; font-size: 1.1rem; cursor: pointer; transition: 0.2s; color: #455a64; box-shadow: 0 4px 0 #cfd8dc; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .btn-opt:active { transform: translateY(4px); box-shadow: none; }
        .btn-opt:hover { background: #e1f5fe; color: var(--blue); }
        .btn-opt img { max-width: 100%; height: 80px; object-fit: contain; margin-top: 5px; }

        #kitList { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 450px; }
        .kit-btn { width: 100%; padding: 20px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 16px; cursor: pointer; text-align: left; font-weight: 700; font-size: 1.2rem; display: flex; justify-content: space-between; align-items: center; transition: 0.2s; }
        .kit-btn:hover { background: rgba(255,255,255,0.2); border-color: var(--gold); transform: translateX(5px); }
    </style>
</head>
<body>

    <div id="toastArea"></div>

    <div id="startScreen" class="modal-overlay open" style="background: var(--bg);">
        <div style="text-align: center; width: 100%; display: flex; flex-direction: column; align-items: center;">
            <i class="fa-solid fa-shield-halved" style="font-size: 4rem; color: var(--gold); margin-bottom: 15px;"></i>
            <h1 style="font-size: 3rem; color: white; margin-bottom: 5px; font-weight: 900; text-transform: uppercase; letter-spacing: 2px;">Color Kingdom</h1>
            <p style="color: var(--blue); margin-bottom: 40px; font-size: 1.1rem; font-weight: 600;">PENTAGON SIEGE EDITION</p>
            <div id="kitList">Đang tải dữ liệu...</div>
        </div>
    </div>

    <div id="turnBanner" class="turn-banner red">LƯỢT CỦA: RED TEAM</div>

    <header>
        <div class="hud red active" id="hudRed">
            <i class="fa-solid fa-flag" style="color:var(--red);"></i>
            <div><div class="score" id="scoreRed">0</div></div>
        </div>
        <div class="timer" id="timer">05:00</div>
        <div class="hud blue" id="hudBlue">
            <div style="text-align:right;"><div class="score" id="scoreBlue">0</div></div>
            <i class="fa-solid fa-flag" style="color:var(--blue);"></i>
        </div>
    </header>

    <main id="mainMap">
        <div class="map-scaler" id="mapContainer">
            <div class="hex-grid" id="hexGrid"></div>
        </div>
    </main>

    <div class="modal-overlay" id="quizModal">
        <div class="card">
            <div style="display:flex; justify-content:center;">
                <img id="qImg" class="q-img" style="display:none;">
            </div>
            <h3 id="qText" class="q-text">...</h3>
            <div id="qOpts" class="opts-grid"></div>
        </div>
    </div>

    <div class="modal-overlay" id="endModal">
        <div class="card" style="border-top: 8px solid var(--gold);">
            <i class="fa-solid fa-trophy" style="font-size: 4rem; color: var(--gold); margin-bottom: 15px;"></i>
            <h1 id="winTitle" style="font-size: 3rem; text-transform: uppercase; margin-bottom: 10px; font-weight: 900;">WINNER</h1>
            <p id="winReason" style="color:#546e7a; margin-bottom: 30px; font-size: 1.2rem; font-weight: 600;">...</p>
            
            <div style="display: flex; justify-content: space-around; font-size: 1.5rem; font-weight: 800; margin-bottom: 30px; background: #cfd8dc; padding: 15px; border-radius: 12px;">
                <div style="color:var(--red)">RED: <span id="finalRed">0</span></div>
                <div style="color:var(--blue)">BLUE: <span id="finalBlue">0</span></div>
            </div>

            <button class="btn-opt" style="width:100%; background:var(--gold); color:#263238; border:none; box-shadow: 0 5px 0 #f57f17;" onclick="saveAndReset()">
                <i class="fa-solid fa-rotate-right"></i> LƯU KẾT QUẢ & CHƠI LẠI
            </button>
        </div>
    </div>
<script>
    // --- 1. OVERRIDE CSS: LÀM KHÍP BẰNG CÁCH SO LE (STAGGERED) ---
    const style = document.createElement('style');
    style.innerHTML = `
        /* Thiết lập khung chứa hàng */
        .hex-row {
            display: flex;
            justify-content: center; /* Canh giữa map */
            margin-top: -26px;       /* Kéo hàng dưới lún lên ngàm vào hàng trên (104px * 0.25) */
        }
        /* Hàng đầu tiên thì không bị kéo lên */
        .hex-row:first-child {
            margin-top: 0;
        }
        /* ĐẨY SO LE CÁC HÀNG CHẴN (Bí quyết khít 100%) */
        .hex-row:nth-child(even) {
            margin-left: 91px; /* Đẩy sang phải nửa ô (90/2 = 45px) + 1px khe hở */
        }

        /* Định hình ô lục giác */
        .hex {
            width: 90px;
            height: 104px;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%) !important;
            margin: 0 1px !important; /* Khe hở siêu mỏng tinh tế */
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        /* Hiệu ứng nổ/phóng to khi chiếm được ô */
        @keyframes captureFlash {
            0% { transform: scale(1); filter: brightness(1); z-index: 10; }
            50% { transform: scale(1.25); filter: brightness(2) drop-shadow(0 0 15px white); z-index: 100; }
            100% { transform: scale(1); filter: brightness(1); z-index: 10; }
        }
        .hex.captured-anim {
            animation: captureFlash 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* Hiệu ứng lơ lửng cho icon căn cứ */
        @keyframes floatBase {
            0%, 100% { transform: translateY(0); filter: drop-shadow(0 2px 2px rgba(0,0,0,0.6)); }
            50% { transform: translateY(-8px); filter: drop-shadow(0 12px 5px rgba(0,0,0,0.4)); }
        }
        .hex.base .icon-lg {
            animation: floatBase 2s ease-in-out infinite;
        }
        
        /* Mặt nước dập dềnh nhẹ */
        @keyframes waterRipple {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-3px) scale(1.02); }
        }
        .hex.water i {
            animation: waterRipple 3s ease-in-out infinite;
        }
    `;
    document.head.appendChild(style);

    // --- SETUP FIREBASE ---
    const firebaseConfig = { apiKey: "AIzaSyCd7vYlpSMcAlgwOPNBMyOhM0QIuzE-628", projectId: "thaococo-70cc7" };
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();

    // --- GAME CONFIG & FIXED MAP (GỌN GÀNG) ---
    let TIME = 300;
    const ROWS = 6, COLS = 6;
    
    // Bản đồ chiến thuật 6x6
    const FIXED_MAP = [
        ['R', 'G', 'G', 'G', 'G', 'G'],
        ['G', 'G', 'M', 'G', 'G', 'G'],
        ['G', 'G', 'W', 'W', 'G', 'G'],
        ['G', 'G', 'W', 'W', 'G', 'G'],
        ['G', 'G', 'G', 'M', 'G', 'G'],
        ['G', 'G', 'G', 'G', 'G', 'B']
    ];

    let state = { grid: [], turn: 'red', scores: { red: 0, blue: 0 }, active: false, timer: 0, kitTitle: 'Trận đấu' };
    let questions = [];
    let timerInt, targetCell = null;
    const urlId = new URLSearchParams(window.location.search).get('id');

    window.onload = () => { if(urlId) loadGame(urlId); else fetchKits(); };

    function toast(msg, type='info') {
        const div = document.createElement('div');
        div.className = `toast ${type}`;
        let icon = type === 'success' ? 'fa-circle-check' : (type==='error'?'fa-circle-xmark':'fa-circle-info');
        div.innerHTML = `<i class="fa-solid ${icon}"></i> <span>${msg}</span>`;
        document.getElementById('toastArea').appendChild(div);
        setTimeout(() => { div.style.opacity = '0'; setTimeout(()=>div.remove(), 300); }, 3000);
    }

    async function fetchKits() {
        const list = document.getElementById('kitList');
        list.innerHTML = "";
        try {
            const snap = await db.collection('kits').limit(20).get();
            snap.forEach(doc => {
                const btn = document.createElement('div');
                btn.className = 'kit-btn';
                btn.innerHTML = `<span>${doc.data().title || 'Vùng đất mới'}</span> <i class="fa-solid fa-play"></i>`;
                btn.onclick = () => window.location.href = `?id=${doc.id}`;
                list.appendChild(btn);
            });
            if(snap.empty) list.innerHTML = "<div style='color:white'>Không tìm thấy bộ câu hỏi nào.</div>";
        } catch(e) { list.innerHTML = "Lỗi kết nối Firebase (Vui lòng kiểm tra tab Rules)"; }
    }

    async function loadGame(id) {
        try {
            const doc = await db.collection('kits').doc(id).get();
            if(!doc.exists) return toast('Lỗi dữ liệu', 'error');
            const d = doc.data();
            state.kitTitle = d.title;
            if(d.timeLimit) TIME = parseInt(d.timeLimit)*60;
            state.timer = TIME;

            let rawQuestions = d.questions || [];
            let questionsArray = Array.isArray(rawQuestions) ? rawQuestions : (rawQuestions && typeof rawQuestions === 'object' ? Object.values(rawQuestions) : []);
            
            questions = questionsArray.map(q => {
                if(!q) return null;
                let qImg = q.qMedia || q.imageUrl || q.image || (typeof q.image==='object'?q.image.url:"") || "";
                let rawOpts = q.options || q.choices || ["A","B","C","D"];
                let opts = rawOpts.map(o => (typeof o === 'string') ? { text: o, media: "" } : { text: o.text || "...", media: o.media || "" });
                return { text: q.text||q.question, opts: opts, correct: q.correctIndex||0, img: qImg };
            }).filter(q=>q);
            
            if(!questions.length) questions=[{text:"Bạn có muốn chiếm ô này?", opts:[{text:"Có"},{text:"Không"}], correct:0}];

            document.getElementById('startScreen').classList.remove('open');
            initBoard();
            startGame();
        } catch(e) { console.error(e); toast('Lỗi tải game', 'error'); }
    }

    function initBoard() {
        const map = document.getElementById('hexGrid');
        map.innerHTML = "";
        state.grid = [];
        state.scores = { red: 0, blue: 0 };

        for(let r=0; r<ROWS; r++) {
            const rowDiv = document.createElement('div');
            rowDiv.className = 'hex-row';
            let rowData = [];

            for(let c=0; c<COLS; c++) {
                const hex = document.createElement('div');
                let cellData = FIXED_MAP[r][c];
                let type = 'grass', pts = 10, owner = null;

                if (cellData === 'R') { type = 'base'; owner = 'red'; pts = 0; }
                else if (cellData === 'B') { type = 'base'; owner = 'blue'; pts = 0; }
                else if (cellData === 'W') { type = 'water'; }
                else if (cellData === 'M') { type = 'mountain'; }

                hex.className = `hex ${type}`;
                if(type === 'base') {
                    hex.classList.add(`base-${owner}`);
                    hex.innerHTML = '<i class="fa-brands fa-fort-awesome icon-lg"></i>';
                } else if(type === 'water') hex.innerHTML = '<i class="fa-solid fa-water" style="opacity:0.6; font-size:1.5rem; color:#81d4fa;"></i>';
                else if(type === 'mountain') hex.innerHTML = '<i class="fa-solid fa-mountain" style="opacity:0.6; font-size:1.5rem; color:#b0bec5;"></i>';
                else hex.innerHTML = `<span class="hex-content">${pts}</span>`;

                hex.onclick = () => onHexClick(r, c);
                rowDiv.appendChild(hex);
                rowData.push({ r, c, type, owner, pts, dom: hex });
            }
            map.appendChild(rowDiv);
            state.grid.push(rowData);
        }
        
        // Tự động thu phóng Map để không bị tràn màn hình
        const scale = Math.min(1, window.innerWidth / (COLS * 95 + 50)); 
        document.getElementById('mapContainer').style.transform = `scale(${scale < 0.5 ? 0.5 : scale})`;
    }

    // Hex Math: Tính ô liền kề khớp 100% với CSS So Le (Staggered)
   function getNeighbors(r, c) {
        // Trong CSS, :nth-child(even) áp dụng cho các hàng thứ 2, 4, 6... 
        // Trong mảng JS (index bắt đầu từ 0), đây tương ứng với các hàng có r = 1, 3, 5... (tức là r % 2 !== 0)
        // Khi hàng r bị đẩy sang phải (margin-left: 91px), các ô lân cận của nó sẽ thay đổi.
        
        const isIndented = (r % 2 !== 0); 
        
        // CÔNG THỨC MỚI KHỚP VỚI CSS CỦA BẠN:
        const offsets = isIndented
            // Nếu là dòng bị thụt vào (r lẻ: 1, 3, 5)
            ? [[-1, 0], [-1, 1], [0, -1], [0, 1], [1, 0], [1, 1]]
            // Nếu là dòng không bị thụt (r chẵn: 0, 2, 4)
            : [[-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]];

        let res = [];
        offsets.forEach(o => {
            const nr = r + o[0], nc = c + o[1];
            if(nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                res.push({r: nr, c: nc});
            }
        });
        return res;
    }
    function isNeighborToFriendly(r, c, color) {
        return getNeighbors(r, c).some(n => state.grid[n.r][n.c].owner === color);
    }

    function onHexClick(r, c) {
        if(!state.active) return;
        const cell = state.grid[r][c];
        
        if(['water','mountain','base'].includes(cell.type)) return toast('Không thể tương tác với ô này!', 'error');
        if(cell.owner === state.turn) return toast('Ô này đã là của bạn!', 'info');
        if(!isNeighborToFriendly(r, c, state.turn)) return toast('Phải đánh chiếm ô nằm giáp ranh với lãnh thổ của bạn!', 'error');

        targetCell = {r, c};
        openQuiz();
    }

    function openQuiz() {
        const q = questions[Math.floor(Math.random()*questions.length)];
        const modal = document.getElementById('quizModal');
        const img = document.getElementById('qImg');

        if(q.img && q.img.length > 5) { img.src = q.img; img.style.display = 'block'; } 
        else { img.style.display = 'none'; }

        document.getElementById('qText').innerText = q.text;
        const optsDiv = document.getElementById('qOpts');
        optsDiv.innerHTML = "";
        
        q.opts.forEach((o, i) => {
            const btn = document.createElement('button');
            btn.className = 'btn-opt';
            let html = `<span>${o.text || ""}</span>`;
            if(o.media && o.media.length > 5) html += `<img src="${o.media}">`;
            btn.innerHTML = html;
            btn.onclick = () => handleAnswer(i === q.correct);
            optsDiv.appendChild(btn);
        });

        modal.classList.add('open');
    }

    function captureSingleCell(r, c, team) {
        const cell = state.grid[r][c];
        if (cell.type !== 'grass') return;

        if (cell.owner !== team) {
            // Trừ điểm của phe bị mất ô
            if (cell.owner) {
                state.scores[cell.owner] -= cell.pts;
                cell.dom.classList.remove(cell.owner); // XÓA MÀU CŨ
            }

            // Cộng điểm cho phe chiếm được
            state.scores[team] += cell.pts;
            cell.owner = team;
            
            // Cập nhật DOM và kích hoạt animation
            cell.dom.classList.add(team); // THÊM MÀU MỚI
            cell.dom.className = `hex ${cell.type} ${team} captured-anim`;
            setTimeout(() => {
                if(cell.dom) cell.dom.classList.remove('captured-anim');
            }, 600);
        }
    }
function handleAnswer(isCorrect) {
        document.getElementById('quizModal').classList.remove('open');
        
        if(isCorrect) {
            // 1. Chiếm ô vừa chọn
            captureSingleCell(targetCell.r, targetCell.c, state.turn);
            toast(`Chiếm đóng thành công!`, 'success');

            // 2. Kích hoạt kỹ năng: Kiểm tra xem có cụm lính địch nào bị vây không thì nuốt luôn
            captureSurroundedEnemies();

            // 3. Kiểm tra bao vây căn cứ địch
            const enemyColor = state.turn === 'red' ? 'blue' : 'red';
            const enemyBasePos = enemyColor === 'red' ? {r:0, c:0} : {r:ROWS-1, c:COLS-1};
            
            if(checkBaseSiege(enemyBasePos, enemyColor)) {
                return endGame(state.turn.toUpperCase(), "CĂN CỨ ĐỊCH ĐÃ BỊ BAO VÂY HOÀN TOÀN!");
            }
            
            switchTurn();
        } else {
            toast('Sai rồi! Mất lượt.', 'error');
            switchTurn();
        }
    }    function checkBaseSiege(basePos, baseColor) {
        let queue = [{r: basePos.r, c: basePos.c}];
        let visited = new Set();
        visited.add(`${basePos.r},${basePos.c}`);

        while (queue.length > 0) {
            let curr = queue.shift();
            let neighbors = getNeighbors(curr.r, curr.c);

            for (let n of neighbors) {
                let nCell = state.grid[n.r][n.c];

                // Nếu từ căn cứ hoặc lính bảo vệ chạm được vào ô cỏ trống -> Căn cứ AN TOÀN
                if (nCell.type === 'grass' && !nCell.owner) {
                    return false; 
                }

                // Tiếp tục loang ra các ô lính của phe mình để tìm đường thoát
                if (nCell.type === 'grass' && nCell.owner === baseColor && !visited.has(`${n.r},${n.c}`)) {
                    visited.add(`${n.r},${n.c}`);
                    queue.push(n);
                }
            }
        }
        
        // Nếu duyệt hết cụm nối liền căn cứ mà không thấy ô trống -> BỊ BAO VÂY
        return true; 
    }
    function startGame() {
        state.active = true;
        timerInt = setInterval(() => {
            state.timer--;
            let m = Math.floor(state.timer/60), s = state.timer%60;
            document.getElementById('timer').innerText = `${m}:${s<10?'0'+s:s}`;
            if(state.timer<=0) endGame(state.scores.red > state.scores.blue ? 'RED' : (state.scores.blue > state.scores.red ? 'BLUE' : 'HÒA'), 'HẾT GIỜ!');
        }, 1000);
        updateHUD();
        toast("BẮT ĐẦU! HÃY BẢO VỆ CĂN CỨ!", "success");
    }

    function switchTurn() {
        state.turn = state.turn === 'red' ? 'blue' : 'red';
        updateHUD();
        const banner = document.getElementById('turnBanner');
        banner.className = `turn-banner ${state.turn}`;
        banner.innerText = `LƯỢT CỦA: ${state.turn.toUpperCase()} TEAM`;
    }

    function updateHUD() {
        document.getElementById('scoreRed').innerText = state.scores.red;
        document.getElementById('scoreBlue').innerText = state.scores.blue;
        document.getElementById('hudRed').classList.toggle('active', state.turn==='red');
        document.getElementById('hudBlue').classList.toggle('active', state.turn==='blue');
        document.getElementById('finalRed').innerText = state.scores.red;
        document.getElementById('finalBlue').innerText = state.scores.blue;
    }

    function endGame(winnerName, reasonText) {
        clearInterval(timerInt);
        state.active = false;
        document.getElementById('winTitle').innerText = winnerName + (winnerName !== 'HÒA' ? " WIN!" : "!");
        document.getElementById('winReason').innerText = reasonText;
        let titleColor = winnerName === 'RED' ? 'var(--red)' : (winnerName === 'BLUE' ? 'var(--blue)' : 'var(--gold)');
        document.getElementById('winTitle').style.color = titleColor;
        updateHUD(); 
        document.getElementById('endModal').classList.add('open');
    }

    async function saveAndReset() {
        try {
            const user = auth.currentUser;
            const emailToSave = user ? user.email : 'Test_Player';
            const idToSave = user ? user.uid : 'guest_' + Math.floor(Math.random()*10000);

            await db.collection('game_results').add({
                kitId: urlId || 'unknown', 
                kitTitle: state.kitTitle || 'Test', 
                redScore: state.scores.red, 
                blueScore: state.scores.blue,
                winner: state.scores.red > state.scores.blue ? 'RED' : (state.scores.red < state.scores.blue ? 'BLUE' : 'DRAW'),
                playedAt: new Date().toISOString(), 
                playerEmail: emailToSave, 
                playerId: idToSave
            });
            toast('Đã lưu kết quả!', 'success');
            setTimeout(() => location.reload(), 1500);
        } catch(e) {
            console.error(e);
            toast('Lỗi lưu kết quả! Vui lòng kiểm tra Firestore Rules nếu bạn đang test Guest.', 'error');
            setTimeout(() => location.reload(), 2500);
        }
    }
// Hàm tìm "đường thoát" cho một cụm ô
    function hasLiberty(cluster) {
        for (let pos of cluster) {
            let neighbors = getNeighbors(pos.r, pos.c);
            for (let n of neighbors) {
                let nCell = state.grid[n.r][n.c];
                // Nếu chạm vào ô cỏ chưa có chủ -> Cụm ô này an toàn (có đường sống)
                if (nCell.type === 'grass' && !nCell.owner) {
                    return true; 
                }
            }
        }
        return false; // Bị bao vây hoàn toàn bởi địch, nước, núi hoặc viền map
    }

    // Hàm quyét và chiếm các ô địch bị bao vây
    function captureSurroundedEnemies() {
        const enemy = state.turn === 'red' ? 'blue' : 'red';
        let visited = new Set();

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = state.grid[r][c];
                
                // Tìm thấy ô của địch chưa được kiểm tra
                if (cell.type === 'grass' && cell.owner === enemy && !visited.has(`${r},${c}`)) {
                    
                    // Thuật toán loang (Flood Fill) để gom toàn bộ các ô liền kề của địch thành 1 cụm
                    let cluster = [];
                    let queue = [{r, c}];
                    visited.add(`${r},${c}`);

                    while (queue.length > 0) {
                        let curr = queue.shift();
                        cluster.push(curr);

                        let neighbors = getNeighbors(curr.r, curr.c);
                        for (let n of neighbors) {
                            let nCell = state.grid[n.r][n.c];
                            if (nCell.type === 'grass' && nCell.owner === enemy && !visited.has(`${n.r},${n.c}`)) {
                                visited.add(`${n.r},${n.c}`);
                                queue.push(n);
                            }
                        }
                    }

                    // Nếu toàn bộ cụm ô địch này KHÔNG có đường thoát -> Phe ta chiếm tất cả
                    if (!hasLiberty(cluster)) {
                        cluster.forEach(pos => {
                            captureSingleCell(pos.r, pos.c, state.turn);
                        });
                        if (cluster.length > 0) {
                            toast(`Tuyệt vời! Đã bao vây và tiêu diệt ${cluster.length} lính địch!`, 'success');
                        }
                    }
                }
            }
        }
    }
</script>
</body>
</html>
